<?php
// $Id$

/**
 * @file
 * This is a backport of og-7.x Group roles and permissions.
 *
 * This module intentionally implements functions in the og 'namespace'
 *  to maintain API compatibility with 7.x.
 *
 * --- API Changes ---
 *
 * Modules must add and remove roles they implement on enable and uninstall
 * respectively because D6 doesn't implement hook_modules_enabled() and
 * hook_modules_uninstalled().
 *  - @see og_set_global_access_module();
 *  - @see og_permissions_delete_by_module()
 * @todo - /BACKPORT/ Consider checking on menu_rebuild (hook_menu_alter).
 *
 *
 */

// Re-implement needed Drupal 7 API functions in a seperate file.
require_once dirname(__FILE__) . '/includes/d7.api.inc';


/**
 * Group default roles and permissions field.
 *
 * @todo - /BACKPORT/ This is an entity field that flags groups with
 *  non-default permissions, that would be CCK in D6, but we may not want
 *  CCK dependency.
 */
define('OG_DEFAULT_ACCESS_FIELD', 'og_roles_permissions');

/**
 * The role name of group non-members.
 */
define('OG_ANONYMOUS_ROLE', 'non-member');

/**
 * The role name of group member.
 */
define('OG_AUTHENTICATED_ROLE', 'member');

/**
 * The role name of group administrator.
 */
define('OG_ADMINISTRATOR_ROLE', 'administrator member');

/**
 * Invalidate cache.
 *
 * @param $gids
 *   Array with group IDs that their cache should be invalidated.
 */
function og_invalidate_cache($gids = array()) {
  // Reset static cache.
  $caches = array(
    'og_user_access',
//    'og_get_group_ids',
    'og_user_role_permissions',
  );

  foreach ($caches as $cache) {
    drupal_static_reset($cache);
  }

  // Let other Group modules know we invalidate cache.
  module_invoke_all('og_invalidate_cache', $gids);
}

/**
 * Determine whether a user has a given privilege.
 *
 * @param $gid
 *   The group ID.
 * @param $string
 *   The permission, such as "administer nodes", being checked for.
 * @param $account
 *   (optional) The account to check, if not given use currently lgroupged in user.
 *
 * @return
 *   Boolean TRUE if the current user has the requested permission.
 *
 * All permission checks in OG should go through this function. This
 * way, we guarantee consistent behavior, and ensure that the superuser
 * can perform all actions.
 */
function og_user_access($gid, $string, $account = NULL) {
  if (variable_get('og_skip_access', FALSE)) {
    // User access should always return TRUE, as Group is requested to
    // skip any access check.
    return TRUE;
  }

  global $user;
  $perm = &drupal_static(__FUNCTION__, array());

  if (empty($account)) {
    $account = drupal_clone($user); // @todo /BACKPORT/ Is a clone really needed here?
  }

  // User #1 has all privileges.
  if ($account->uid == 1) {
    return TRUE;
  }

  // Administer Group permission.
  if (user_access('administer group', $account)) {
    return TRUE;
  }

  $group = node_load($gid);
  if (!$group || og_is_group_type($group->type)) {
    // Not a group.
    return FALSE;
  }

  // Group manager has all privileges (if variable is TRUE).
  if (variable_get('og_group_manager_full_access', TRUE)) {
    if (!empty($group->uid) && $group->uid == $account->uid) {
      return TRUE;
    }
  }

  // To reduce the number of SQL queries, we cache the user's permissions
  // in a static variable.
  if (!isset($perm[$gid][$account->uid])) {
    $roles = og_get_user_roles($gid, $account->uid);
    $role_permissions = og_user_role_permissions($roles);

    $perms = array();
    foreach ($role_permissions as $one_role) {
      $perms += $one_role;

      $perm[$gid][$account->uid] = $perms;
    }
  }

  return isset($perm[$gid][$account->uid][$string]);
}

/**
 * Check if group should use default roles and permissions.
 *
 * @param $gid
 *   The group ID.
 * @return
 *   TRUE if group should use default roles and permissions.
 */
function og_is_group_default_access($gid) {
  // @todo - /BACKPORT/ This tests an entity field that flags groups with
  //  non-default permissions, that would be CCK in D6, but we may not want
  //  CCK dependency.
  //$return = TRUE;
  $return = FALSE; // @todo - /BACKPORT/ Force custom perms on for now.
  if ($node = node_load($gid)) {

    $property = OG_DEFAULT_ACCESS_FIELD;

    if (!empty($node->{$property}) && $wrapper = $node->{$property}) {
      $return = empty($wrapper[0]['value']);
    }
  }

  return $return;
}

/**
 * Determine the permissions for one or more roles.
 *
 * @param $roles
 *   An array whose keys are the role IDs of interest.
 *
 * @return
 *   An array indexed by role ID. Each value is an array whose keys are the
 *   permission strings for the given role ID.
 */
function og_user_role_permissions($roles = array()) {
  $cache = &drupal_static(__FUNCTION__, array());

  $role_permissions = $fetch = array();

  if ($roles) {
    foreach ($roles as $rid => $name) {
      if (isset($cache[$rid])) {
        $role_permissions[$rid] = $cache[$rid];
      }
      else {
        // Add this rid to the list of those needing to be fetched.
        $fetch[] = $rid;
        // Prepare in case no permissions are returned.
        $cache[$rid] = array();
      }
    }

    if ($fetch) {
      // Get from the database permissions that were not in the static variable.
      // Only role IDs with at least one permission assigned will return rows.
      $result = dbtng_query("SELECT rid, permission FROM {og_role_permission} WHERE rid IN (:fetch)", array(':fetch' => $fetch));

      foreach ($result as $row) {
        $cache[$row->rid][$row->permission] = TRUE;
      }
      foreach ($fetch as $rid) {
        // For every rid, we know we at least assigned an empty array.
        $role_permissions[$rid] = $cache[$rid];
      }
    }
  }

  return $role_permissions;
}

/**
 * Retrieve an array of roles matching specified conditions.
 *
 * @param $gid
 *   The group node ID.
 * @param $permission
 *   Optional; A string containing a permission. If set, only roles containing
 *   that permission are returned.
 * @param $force_group
 *   Optioanl; If TRUE then the roles of the group will be retrieved by the
 *   group ID, even if the group is set to have default roles and permissions.
 *   The group might be set to "Default access" but infact there are inactive
 *   group roles. Thus, we are forcing the function to return the overriden
 *   roles. see og_delete_user_roles_by_group().
 *
 * @return
 *   An associative array with the role id as the key and the role name as
 *   value. The anonymous and authenticated deault roles are on the top of the
 *   array.
 */
function og_user_roles($gid = 0, $permission = NULL, $force_group = FALSE) {
  $roles = array();

  // Check if overriden access exists.
  if (!$force_group) {
    $gid = og_is_group_default_access($gid) ? 0 : $gid;
  }

  if (!empty($permission)) {
    $roles = dbtng_query("SELECT r.rid, r.name FROM {og_role} r INNER JOIN {og_role_permission} p ON r.rid = p.rid WHERE p.permission = :permission AND r.gid = :gid ORDER BY r.name", array(':permission' => $permission, ':gid' => $gid))->fetchAllKeyed();
  }
  else {
    $roles = dbtng_query("SELECT rid, name FROM {og_role} WHERE gid = :gid ORDER BY rid", array(':gid' => $gid))->fetchAllKeyed();
  }

  return  $roles;
}

/**
 * Get all roles of a user in a certain group.
 *
 * @param $gid
 *   The group ID.
 * @param $uid
 *   The user ID.
 * @param $include
 *   Optional; If TRUE also anonymous or authenticated role ID will be returned.
 *   Defaults to TRUE.
 * @return
 *   Array with the role IDs of the user.
 */
function og_get_user_roles($gid, $uid = NULL, $include = TRUE) {
  $roles = array();

  if (empty($uid)) {
    global $user;
    $uid = $user->uid;
  }

  if ($include) {
    // Check if overriden access exists.
    $query_gid = og_is_group_default_access($gid) ? 0 : $gid;

    $group_roles = og_user_roles($query_gid);

    // @todo - /BACKPORT/ og_is_group_member() calls user_load, uncached, perhaps too expensive / try global user if possible.
    $name = og_is_group_member($gid, FALSE, $uid) ? OG_AUTHENTICATED_ROLE : OG_ANONYMOUS_ROLE;
    $rid = array_search($name, $group_roles);
    $roles[$rid] = $rid;
  }

  $roles = $roles + dbtng_query("SELECT rid, rid FROM {og_users_roles} WHERE uid = :uid AND gid = :gid", array(':uid' => $uid, ':gid' => $gid))->fetchAllKeyed();

  return $roles;
}
